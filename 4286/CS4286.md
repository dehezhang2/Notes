# CS4286: Internet Security & E-commerce Protocols

## Lecture 01: Admin & Introduction

### Intro

* Assessment: 
  * 30 course work = 20 (assignments * 3) + 10 (midterm)
  * 70 final

### Basic Concepts

* Relate to
  * Whether valuable
* Why important
  * Unconditionally: Infinite cannot break
  * Computationally: Available resource cannot break
  * Financially: Not profitable to take
* How to know security or not
  * module
  * system
* Sevice & Mechanism
  * Service: High level security goal
  * Mechanism: Accutal way to provide service
* Data Confidentiality and Integrity
  * Confidentiality: Prevent
  * Integrity: Detect, Recover
* Authentication
  * Origin: who did that (does not need provide entity authentication)
    * Signature of check
  * Entity: Whether a specific person (message from which person)
* Non-repudiation: no denial
  * origin: cannot say not send
  * Delivery: cannot say not receive
* Mechanisms: 

------------------------------

## Basic Number Theory & CRT & Euler Function & RSA

### Basic Number Theory

* Modular Arithmetic: 

  * Addition / Subtraction: $(x+y)\ mod\ n = ((x\ mod\ n)+(y\ mod\ n))$

  * Multiplication: $(xy)\ mod\ n = (x\ mod\ n)(y\ mod\ n)\ mod\ n$ 

    * proof: 
      $$
      x=k_1n+b_1, y = k_2n+b_2 (k_1, k_2, b_1, b_2\ \in \mathbb N^*)\\ 
      (xy)\ mod\ n = (k_1n+b_1)(k_2n+b_2)\ mod\ n\\
      =(k_1k_2n^2 + (k_1b_2+k_2b_1)n + b_1b_2)\ mod\ n \\
      =b_1b_2 \\
      (x\ mod\ n)(y\ mod\ n) = ((k_1n+b_1)\ mod\ n)((k_2n+b_2)\ mod\ n) \\
      =b_1b_2
      $$

    * $x^y\ mod\ n = (x\ mod\ n)^y\ mod\ n$ 

    * Example: find the last digit of $2^{100}$ in decimal: 

      ![1579753757940](CS4286.assets/1579753757940.png)

  * Note that if $ac \equiv bc (mod\ n)$ we can get $a \equiv b(mod\ n)$ only when $gcd(n,c) = 1$, or generally: 
    $$
    a \equiv b (mod\ {n \over gcd(c,n)})
    $$
    

* Greatest Common Divisor(GCD)

  * Definition: The largest divisor shared by a given pair of integers

  * Coprime: Two integers $x, y$ are coprime(relatively prime) iff $gcd(x,y)=1$

  * Euclidean’s Algorithm: If $a = qb + r$ for some integer $q$ and $r$, then:
    $$
    gcd(a,b)=gcd(r,b) = gcd(a\ mod\ b, b)
    $$

    * proof: 
      $$
      r = a\ mod\ b \\
      r = a-qb \\
      {r\over d} = {a \over d} - {qb \over d} = m \\(where\ d\ is\ a\ common\ divisor\ of\ a\ and\ b => m \in \mathbb N^*)\\
      m\ is\ a\ divisor\ of\ r
      $$

    * code: 

      ```c++
      int gcd(int a, int b) 
      { 
          // Everything divides 0  
          if (a == 0) 
             return b; 
          if (b == 0) 
             return a; 
         
          // base case 
          if (a == b) 
              return a; 
         
          // a is greater 
          if (a > b) 
              return gcd(a%b, b); 
          return gcd(a, b%a); 
      } 
      ```

  * Extended Euclidean’s Algorithm: 

    * problem: Solve the equation $ax+by=gcd(a,b)​$

      * Always keep the first parameter of $gcd$ to be the larger one
      * The equation always has a solution

    * Base case: $b=0$, that means the previous $gcd(a,b)$ satisfies $a\%b = 0$ , and $b$ becomes current $a$, then $a$ itself is $gcd$ => $gcd*1+0 = gcd$ 

    * Other cases: $b \neq 0$: according to the Euclidean’s Algorithm $gcd(a,b)=gcd(b, a\ mod\ b)$
      $$
      ax + by = gcd(a, b), a = bq +r, r = a - floor({a \over b})b\\
      gcd(b, a\ mod\ b) = gcd(b,r)=bx^\prime + ry^\prime=bx^\prime+(a - floor({a \over b})b)y^\prime \\
      = bx^\prime+ay^\prime - floor({a \over b})by^\prime \\
      = ay^\prime + b(x^\prime - floor({a \over b})y^\prime) \\
      gcd(a,b) = gcd(b,r) \\
      x = y^\prime, y= x^\prime - floor({a \over b})y^\prime
      $$

    * code:

      ```c++
      int exGcd(int a,int b,int &x,int &y)
      {
          if(b==0)
          {
              x=1;y=0;
              return a;
          }
          int r=exGcd(b,a%b,x,y);
          int t=x;x=y;y=t-a/b*y;
          return r;
      }
      ```

  * Least Common Multiple (LCM): 
    $$
    lcm(x,y) \geq max(x,y)\ for\ any\ x,y \\
    lcm(x,y) \leq xy \\
    lcm(x,y) = {xy \over gcd(x,y)}
    $$

* Modular Inverse: 

  * Definition: $b^{-1}$ is called a inverse of $b$ iff
    $$
    bb^{-1} \equiv 1 (mod\ n)
    $$

  * The inverse doesn’t always exist (e.g. $2x \equiv 1 (mod\ 4)$)

  * Inverse exists only if
    $$
    gcd(b,n)=1
    $$

    * Proof: 

      * When $gcd=1$
        $$
        bs + nt = gcd(b,n) = 1 \\
        (bs + nt)\ mod\ n=bs\ mod\ n=1\\
        s = b^{-1}
        $$
        

        * $s,t$ are integers, $gcd$ is less than or equal to minimum of $b$ and $n$, so $s$ and $t$ must have one negative number (otherwise, the value of $gcd$ will be larger than either $b$ or $n​$, which is a contradiction)

      * If $gcd$ is not 1, the minus(difference) between multiple of  $b$ and $n$ will be multiple of $gcd(b,n)​$: 

    $$
    Assume\ b = gcd(b,n)*k_1, n = gcd(b,n)*k_2 \\
    bs + nt = k_1s*gcd(b,n) + k_2t*gcd(b,n) \\
    =gcd(b,n)*(k_1s+k_2t)
    $$


### Chinese Reminder Theorem (CRT)

* Problem: Find the value of $x$ such that: 
  $$
  \begin{cases}
  x \equiv a_1\ (mod\ n_1) \\
  x \equiv a_2\ (mod\ n_2) \\
  \vdots \\
  x \equiv a_k\ (mod\ n_k) \\
  \end{cases}
  $$

*  

### Euler Function and Euler Theorem

* Definition: Euler Function $\phi$ is defined as:
  $$
  \phi(n) = |\{x \in (\mathbb N^* \cap [1,n-1]) \ |\ gcd(x,n)=1\}|\ where\ (n \in (\mathbb N^*\cap[1, +\infty))
  $$

  * The number of positive integers less than $n$ such that $n$ and the integers are coprime.  

  * Denote the set: 
    $$
    Z_n =\{x \in (\mathbb N^* \cap [1,n-1]) \ |\ gcd(x,n)=1\}\ where\ (n \in (\mathbb N^*\cap[1, +\infty)) \\
    |Z_n| = \phi(n)
    $$

* The value of Euler Function: 

  * For prime number $p$: 
    $$
    \phi(p) = p-1
    $$

  * For prime number $p$ , $q$: 
    $$
    \phi(pq) = (pq - 1) - (p - 1) - (q - 1) = pq - p - q + 1 = (p-1)(q-1)
    $$

    * proof: 
      $$
      gcd(p, q) = 1 \\
      Z_{pq} = \{1, 2,...,pq -1\} - \{p, 2p, ..., (q-1)p\} - \{q, 2q, ..., (p-1)q\} \\
      |Z_{pq}| = (pq - 1) - (p - 1) - (q - 1)
      $$

  * For prime number $p$ and a positive integer $k$: 
    $$
    \phi(p^k) = p^k - p^{k-1} = p^k(1-{1 \over p})
    $$

      * proof: 

          * $p^k$ is not calculated in the set, $p^k-p$ is the last multiple of $p$ 

    $$
    Z_{p^k} = \{1, 2,..., p^k-1\} - \{p, 2p,...,(p^{k-1}-1)p\}\\
    =(p^k-1)-(p^{k-1}-1)
    $$

  * For positive integer $p​$, $q​$, $gcd(p,q) = 1​$
    $$
    \phi(pq) = \phi(p)*\phi(q) \\
    $$

    - proof: we only need to prove there is a double mapping from cartesian product of $Z_p$ and $Z_q$ to $Z_{pq}$ 

      - From left to right: prove $a\in Z_p, b \in Z_q \longrightarrow (aq+bp)\ mod\ (pq) \in Z_{pq}$

        - Prove the correspondence: Euclidean Algorithm is used in the last two steps

        $$
        gcd(a,p) = gcd(b,q) = gcd(p,q) = 1 \\
        (aq+bp)\ mod\ p = aq, (aq+bp)\ mod\ q = bp\\
        gcd(aq+bp, p) = gcd(p, aq) = 1 = gcd(q, bp) = gcd(aq+bp, q)\\
        Therefore,\ gcd(aq+bp, pq) = 1 \longleftrightarrow gcd((aq+bp)\ mod\ pq, pq) = 1 \\
        (aq+bp)\ mod\ pq \in Z_{pq}
        $$

        - Prove no two pairs $(a_1, b_1), (a_2,b_2)$ in $Z_p \times Z_q$ corresponds to the same value in $Z_{pq}$ (one-to-one)
          $$
          Assume\ a_1q+b_1p \equiv a_2q + b_2p\ (mod\ pq) \\
          (a_1-a_2)q+(b_1-b_2)p=kpq \\
          (b_1-b_2)p \equiv 0\ (mod\ q) \\
          b_1 \equiv b_2 (mod\ q) \\
          b_1 < q, b_2 < q \\
          b_1=b_2 \\
          similarly, a_1=a_2
          $$

      - From right to left: Define function $f: Z_{pq} \mapsto Z_p \times Z_q\ s.t.\ f(x) = (x\ mod\ p, x\ mod\ q)$  

        - Prove the correspondence: 
          $$
          gcd(pq,x) = 1 \\
          gcd(p,x) = 1, gcd(q,x) = 1 \\
          gcd(x\ mod\ p, p) = gcd(x\ mod\ q, q) =1 \\
          x\ mod\ p \in Z_p, x\ mod\ q \in Z_q
          $$

        - one-to-one

        $$
        Assume\ a,b \in Z_{pq} , a \neq b, f(a) = f(b)\\
        a \equiv b\ (mod\ p), a \equiv b\ (mod\ q)\\
        gcd(p,q) = 1 \longrightarrow a \equiv b\ (mod\ pq) \\
        a , b\in [1,pq) \cap \mathbb N^* \\
        a = b\ (contradiction)
        $$

  * For any positive integer $n$, which is a multiple of $r$ prime numbers: 
    $$
    n = p_1^{k_1}p_2^{k_2}...p_r^{k_r}(k_i \geq 1)\\
    \phi(n) = \phi(p_1^{k_1})\phi(p_2^{k_2})...\phi(p_n^{k_n}) \\
    = p_1^{k_1}p_2^{k_2}...p_r^{k_r}(1-{1 \over p_1})(1-{1 \over p_2})...(1-{1 \over p_r}) \\
    =\Pi^r_{i=1}p_i^{k_i}(1-{1 \over p_i}) \\
    = n\ \Pi^r_{i=1}(1-{1 \over p_i})
    $$

* Euler’s Theorem

  * For positive integer $a$ and $n$, if $gcd(a,n)=1$, $a^{\phi(n) }\equiv 1 (mod\ n)$ ($a^{-1} \equiv a^{\phi(n)-1}\ (mod\ n)$) 

  * proof: 

    * $Z_n=\{x_1, x_2, ..., x_{\phi(n)}\}, S=\{ (a*x_1)\ mod\ n, (a*x_2)\ mod\ n ,...,(a*x_{\phi(n)})\ mod\ n \}$, then $Z_n = S$ 
      $$
      gcd(x_i, n) = gcd(a,n)=1 \\
      gcd(ax_i,n) = 1, gcd(ax_i\ mod\ n, n) = 1\\
      ax_i\ mod\ n \in Z_n \\
      Assume\ ax_i \equiv ax_j (mod\ n) \\
      a(x_i-x_j) = kn, gcd(a,n) = 1\\
      x_i-x_j\equiv0(mod\ n), x_i<n, x_j<n \\
      x_i=x_j
      $$

    * According to the equivalent relationship above: 
      $$
      (a^{\phi(n)}*\Pi_{i=1}^{\phi(n)}x_i)\ mod\ n\\
      = (ax_1\ mod\ n)*(ax_2\ mod\ n)*...(ax_{\phi(n)}\ mod\ n)\ mod\ n\\
      = \Pi_{s\in S} s = \Pi_{x \in Z_n}x \\
      = (x_1*x_2*...*x_n) mod\ n = (\Pi_{i=1}^{\phi(n)}x_i)mod\ n \\
      a^{\phi(n)} \equiv 1(mod\ n)
      $$


### RSA Algorithm

* Notations: 

  * $M$: message
  * $C$: encrypted message
  * {$n,e$}: public key
  * {$d,n$}: private key

* Set up: 

  * pick two prime numbers (larger better) $p, q$

  * $n=p*q$ , the length of $n_{binary}$ is the length of the encrypt key

    * we require that $M < n$ during encryption

  * compute $\phi(n) = (p-1)(q-1)$  

  * pick an integer $e$ **randomly** such that $gcd(e, \phi(n))=1$

  * compute $d\equiv e^{-1}(mod\ \phi(n))$ 
    $$
    ed \equiv 1 (mod\ \phi(n)) \\
    ed - 1 = k\phi(n) \\
    ex + \phi(n)y=1
    $$

* Encryption: 
  $$
  C = M^e\ mod\ n (where\ M < n)
  $$

* Decryption: 
  $$
  M = C^d\ mod\ n = M^{ed}\ mod\ n
  $$

* Proof of correctness: 
  $$
  ed \equiv 1(mod\ \phi(n)) \\
  ed = h\phi(n) + 1 \\
  M^{h\phi(n)+1}\ mod\ n= M \\
  $$

  * when $gcd(M,n)=1$ , according to Euler’s theorem
    $$
    M^{h\phi(n)} \equiv 1(mod\ n) \\
    M^{h\phi(n) + 1} \equiv M (mod\ n)
    $$

  * when $gcd(M,n)\neq 1$, according to Euler’s theorem

    * By assumption, $M < n$ 

    $$
    n=pq \leftrightarrow M=kp\ or\ M=kq \\
    if\ gcd(k,q) \neq 1, q\ is\ prime, M=kp > pq=n\\
    (kp)^{q-1} \equiv1(mod\ q)\\
    [(kp)^{q-1}]^{h(p-1)} * kp \equiv kp (mod\ q) \\
    (kp)^{h\phi(n)+1} \equiv kp(mod\ q) \\
    (kp)^{ed} \equiv kp(mod\ q)\\
    (kp)^{ed} = tq + kp \\
    tq = kp[(kp)^{ed-1}-1] \\
    gcd(p,q) = 1 \rightarrow t = t^\prime p \\
    (kp)^{ed} = t^\prime pq + kp \\
    M^{ed} \equiv M(mod\ n)
    $$

* Security

  * is it possible to calculate $d$ with known $n$ and $e$ 
    $$
    ed \equiv 1 (mod\ \phi(n)) (need\ \phi(n))\\
    \phi(n) = (p-1)(q-1)\ (need\ p\ q)\\
    n=pq\\
    $$

  * if $n$ can be break into two prime numbers, $d$ can be computed => harder to break large $n$, harder to break RSA