# CS 2312

---------

## Lecture 1

------

### 1. Explanation of the Program

* Class name start with Uppercase, same as the file name
* static means we don't need to initialize object to run the main function
* ```args[]``` is an array of String (Strings after the command line run the java code)

### 2. Packages

* Groups of classes ```java.util.*``` where * represent all the class under the folder
* ```import static java.lang.math``` where static means if we use static methods in the imported class
* A class not grouped into package folder and has the packet statement
* Comment : /** */ for automatic documentation

### 3. Data types

* Division
  * 8 primitive types : boolean, byte, short, int, long, float, double, char
  * Reference type : 
    * Built-in Java classes : String, Math, Scanner
    * User-defined classes 
    * Ab array is also a object

* Integer types

  * java has no unsigned types (memory is not so precious now)
  * Long integer numbers have a suffix L (add L at the end of the number)
  * Similarly, provide in Binary add prefix '0b', provide in Hexadecimal, add prefix '0x'

* Floating point

  * Three special values to denote overflows and errors
    * Positive infinity
    * Negative infinity
    * NaN (not a number)
  * Float suffix 'F' double no suffix or add 'D' 
  * E+18 represent $*10^{18}$ 
  * can not get specific value during the calculation (Use the BigDecimal class)

* boolean type : cannot converted from integer

* char type: '\u+unicode' to get the char (covert at first even before "" and comment)

  ```java
  System.out.println("\u0022+\u0022"); // print nothing
  // \u00A0 is new line => syntax error
  // also
  $ javac test.java
  test.java:3: ▒▒▒▒: ▒Ƿ▒▒▒ Unicode ת▒▒
      // Look inside c:\users
                         ^
  1 ▒▒▒▒▒▒
  
  ```

* Big numbers : used when the integer and floating-point types is not sufficient

  * Turn into couple of handy classes in the ```java.math``` package: BigInteger and BigDecimal => manipulating numbers with an arbitrarily long sequence of digits

  * ```valueOf()``` method to turn an ordinary number(normal integer) into a big number

  * Cannot use + * ...

    ```java
    BigInteger a = BigInteger.valueOf(100);
    BigInteger c = a.add(b);
    BigInteger d = c.multiply(b.add(BigInteger.valueOf(2)))
    ```

* Constants

  * Java keyword is ```final``` , means the value cannot be changed any more

  * class constant : ```static final```

    ```java
    final double MAX;
    //in class
    public static final int MAX;
    ```

-----------

## Lec 3

--------

* INPUT

  ```java
  Scanner in = new Scanner(new File(filepath));
  in.next();		// 	read until meet white space
  in.nextline();	//	read the whole line of remain (if a string is read by in.next(), it is dropped from input stream)
  ```


### 1. Strings

* Sequence of unicode 

* Empty string : => different from null

  ```java
  str.length()==0;
  // or
  str.equals("");
  ```

  

* Declare

  ```java
  String s = new String("Hello")
  String s = "Hello";
  ```

* Length field : ```s.length()``` : the public method (**not field**)

  * "" is empty string different from null

  * to get the code unit length  use ```cnt=strobj.codePointCount(0,strobj.length())``` 

  * to get ith code point , do not use ```charAt()``` method

    ```java
    int index = greeting.offsetByCodePoints(0,i);
    int cp = greeting.codePointAt(index);
    ```

  * As usual it returns same value as length() method

    * when there is a character requires two code units in UTF-16

  ```java
  for(s!=null&&s.length()!=0)
  ```

* ```substring(i,j)``` method yields substrings from i-th(from 0) char to (j-1)-th char

* ```charAt(i)``` returns i-th char

* \+ 

  ```
  String greeting = "Hello"; String s;
  s = 1000 + " " + greeting; // "1000 Hello"
  s = 1000 + ' ' + greeting; // "1032Hello" ' '==32
  ```

* ```equals()``` use ```s.equals("somestring")``` cannot use ```==``` because it compare the Object ID

* Covert string to integer

```java
String input = "7";
int n = Integer.parseInt(input);
```

* Strings are immutable

  * No method can change a character in an existing string
  * To change the value of string is not convenient
  * substring() method actually create new object
  * garbage collection => useless object automatically distroyed
  * If you want to change a character in a string, use substring method

  ```java
  greeting = greeting.substring(1,3);	//"Hello" is deleted, "el" is the new one
  greeting = greeting.substring(0,3)+"p!"; 
  /* copy the substring add characters you want to change, assign the reference to the current object, finally get a new object, and the old one is deleted by garbage collection*/
  ```

### 2. StringBuilder (import java.util.StringBuilder)

* Used for concatenation and other operation which change the value of the string

  ```java
  StringBUilder sb = new StringBuilder();
  sb.append("Hello ");
  ```

### 3. Read Input

(1) Reading inpit from Console

* Construct

  ```java
  Scanner in = new Scanner(System.in)
  ```

* next(), nextline() => return a string

* Close: ```in.close()``` avoid some problems

(2) read from a file

```java
Scanner inFile = new Scanner(new File(fileName));
while (inFile.hasNext()) {
String line = inFile.nextLine();
..
}
inFile.close();
```

(3) Reading input from another string

```
String str;
Scanner in = new Scanner(str);
```

(4) print by line

```java
System.out.print("Enter a line of words: ");
Scanner scannerConsole = new Scanner(System.in);

while (scannerConsole.hasNext())
	System.out.println(scannerConsole.next());
scannerConsole.close();
```

* Scanner is not suitable for reading  password (java.io.Console)

  ```java
  Console cons = System.console();
  String username = cons.readLine("User name: ");
  char[] passwd = cons.readPassword("Password: ");
  ```

  

### 4. format output

* Using .print, .println for floating-point values (problem):

* Using .printf – formatted output (solution)

  | Conversion Character | Type                                           | Example         |
  | -------------------- | ---------------------------------------------- | --------------- |
  | d                    | Decimal number                                 | 159             |
  | x                    | Hexadecimal number                             | 9f              |
  | o                    | Octal number                                   | 237             |
  | f                    | Fixed-point floating-point                     | 15.9            |
  | e                    | Exponential floating-point                     | 1.59e+01        |
  | g                    | General floating-point(the shorter of e and f) | --              |
  | a                    | Hexadecimal floating-point                     | 0x1.fccdp3      |
  | s                    | String                                         | Hello           |
  | c                    | Character                                      | H               |
  | b                    | boolean                                        | true            |
  | h                    | Hash Code                                      | 4268b2          |
  | tx or Tx             | Date and time                                  | Java.time class |
  |                      |                                                |                 |

  

  ```java
  double x = 10000.0 / 3.0;
  System.out.printf("%8.2f", x);//prints 3333.33; 8 is width of integer, 2 is digits after the point
  System.out.printf("%,.2f",10000.0/3.0)	// 3,333.33
  ```

* Similar to create a string

  ```java
  String out = String.format(“Hi %s. Next year you'll be %d", name, age+1);
  ```

* File Input and Output

  * Construct a ```Scanner``` object like this

    ```java
    Scanner in = new Scanner(Paths.get("myfile.txt"),"UTF0-8");
    Scanner in = new Scanner(new File("myfile.txt"));
    //output i.e. write to a new file
    PrintWriter out = new PrintWriter("myfile.txt","UTF-8");
    // Error
    Scanner in = new Scanner("myfile.txt") // directly read the string
    ```

  * when using relative file name, such as "my file.txt" ==the file should be located at the same directory that JVM was started==

  * If you fail to do it  you should ```throws IOExpection``` 

### 5. Control Flow

* Control structures (similar to C++)

* Block Scope (compound statement inside{})

* Cannot declare identically named variables in 2 nested blocks (innerloop and outer)

* Break; and continue; => use them only to improve the coding quality

* Labeled break : 

  ```java
  //labeled break
  outer:
  while(...){
      for(...){
          break outer;
      }
  }
  ```

  

  ```java
  bFound=false;
  for (i=0;i<n;i++){
  	if (A[i]==x){
  		bFound=true;
  		break;
  	}
  }
  // use this one
  bFound = false;
  for(int i=0;i<n&&!bFound;i++)
  	if(A[i]==x)
          bFound = true;
  ```

### 6. Array

* An array is a collection of elemebnts of the same type

* As an object in java

* Autometically initial each entrie to 0 (boolean array initialize 'false', object array initialize null)

* size of an array is immutable

  ```java
  int[] arr; // int[] is the array type; arr is the array name
   // int arr[]; is also okay, but not welcome by Java fans
  arr = new int[5]; //create the array;
  arr[0] = 3;
  arr[1] = 25;
  for (int i=0;i<arr.length;i++) //use .length to tell the array size
   System.out.println(arr[i]);
  ```

* Styles of array declaration:

  ```java
  int[] arr;
  arr = new int[5];
  arr[0] = 3;
  arr[1] = 25;
  
  int[] arr = new int[5];
  arr[0] = 3;
  arr[1] = 25;
  
  int[] arr = {3,5,0,0,0};
  int[] arr = new int[]{3,5,0,0,0};
  ```

* For each loop : cannot used to initialize (for each 按值传递基本数据类型， 按地址传递object,并赋给variable)

  * when variable is primary type: the value of the copy changed
  * when variable is object : the reference of the variable changed to a new object, but the elements in the array has not been changed

  ```java
  for(variable:collection) 
  	statement;
  for(int item:arr)
      System.out.println(item);
  ```

* Array.toString(arr)

  ```java
  int[] arr = {3,5,0,0,0};
  System.out.println(Arrays.toString(arr)); 	//[3, 5, 0, 0, 0]
  ```

* Array.sort(arr)

  ```java
  Arrays.sort(arr);
  System.out.println(Arrays.toString(arr));
  ```

* Array.copyOf(arr,len) : return a new array copied number of len elements

  * the returned array points to a different new object as the original array
  * common use of this method : resizing array

  ```java
  arr = Arrays.copyOf(arr,arr.length*2);
  ```

* Multidimensional arrays

  ```java
  balances = new double[NYEARS][NRATES];
  int[][] magicSqr = {
      {1,2,3},
      {4,5,6},
      {7,8,9}
  };
  for(double[] row:arr)
      for(double value:row)
          // do something with value
  ```

  

### 7. class

* ```toString()``` is autometically called in ```System.out.println()```;

----------------

### 4.1 Introduction to OOP

#### 4.1.4 Relationships between Classes

* Dependence : ("use-a")

* Aggregation : ("has-a")

* Inheritance : ("is-a")

* Mutator : set(), Accessor: get()

* Initialize : to null or assign another object to it

* Swap(Obj 1, Obj 2) => 

  * Swap the reference (wrong) (can be done directly in main function)

    ```java
    Obj temp = 1;
    1 = 2;
    2 = temp;
    ```

    

  * Swap the value (right)

    ```java
    int temp = 1.val;
    1.val=2.val;
    2.val = temp
    ```

* Default field

  * Number : 0
  * Truth value : false
  * object reference : null
  * default constructor
    * If don't have constructor, java will provide a default constructor
    * If there is constructor, but no defult constructor, there will be complition error when you use the default constructor

  ```java
  public Employee(){
      name = null;
      salary = 0;
      hireDay = null;
  }
  ```

  

* Overloading methods

  * Signature : name and parameters

* Constructor : Constructors can only called by the ```new``` operator

  * Cannot construct an object without ```new``` operator, for e.g.

    ```C++
    Employee number007("James Bond" , 100000, 1950,1,1);
    ```

* accessors and mutators

  * Fields are set to be private => Encapsulation

  * Get and set methods help the user to access or change the value of the field

  * if any thing wrong, just need to debug the set or get methods

  * not to write accessor methods that return references to mutable objects i.e.

    ```java
    public Date getHireDay(){
        return (Date) hireDay.clone();
    }
    ```

* Class-Based Access Privileges

  *  Method can access the private data of the object on which it is invoked
  * Method can access other object of the class even it is not the current class

* private method => helper methods

* Final Instance Fields => must be initialized when the object constructed, and never be changed after that

  * Useful for the fields whose type is primitive or an *immutable class* 

* Static methods and fields : belongs to the class 

  * Factory methods : Used to construct objects

* 

--------------

### Inherance

* super() method : 

  * if no explicit call, the constructor of child class will implicitly call the default constructor of the super class

* Polymorphiam and Dynamic Binding

  * Polymorphism : An object variable(super class) can refer to different actual types(as long as it is child) (compile time checking) (可以指向子类对象¯)
  * Dynamic Binding : Automatically select the appropriate ==non-static method== (Not field) (调用指向对象类型的函数)

* Final class and final method : 

  * avoid being inherited or redefined

* Casting and instanceOf

  * Upcasting => cast a child to its super class

  * Downcasting => cast a parent to its child class (because the parents may not be reference to the child class object) => use instances keyword

    ```java
    for(Employee e:allEmployees){
        if(e instanceof Manager){
    		Manager m;
            m = (Manager)e;
            System.out.println(m.getBonus());
        }
    }
    ```

    

  * if a method is a rewrite method => use the dynamic binding

  * if a method is a new subclass method => use Downcasting

------------

### Object : The Cosmic Superclass

-----------

* every class automatically "is-a" subclass of Object class

* Override equals

  ```java
  public boolean equals(Object otherObject){
      if(otherObject==null) return false;
      if(otherObject.getClass()!=this.getClass())
          return false;
      // casting
      Subject otherSR = (SubjectResult) otherObject;
      if(!this.name.equals(otherSR.name)) 
          return false;
      ...
      // check all the fields
      return true;
   
  }
  ```

* Java primitive types and Wrappers

  * all primitive types have its own Wrappers (int-> Integer)

  * Arraylist can only store Wrappers ```Arraylist<Integer>``` arrlist

  * arrlist = new ArrayList<>(); => The compiler itself will check what type is needed s

  * in a for-each loop, the iterator should not be changed during using the iterator

  * 逻辑上讲，迭代时可以添加元素，但是一旦开放这个功能，很有可能造成很多意想不到的情况。 比如你在迭代一个ArrayList，迭代器的工作方式是依次返回给你第0个元素，第1个元素，等等，假设当你迭代到第5个元素的时候，你突然在ArrayList的头部插入了一个元素，使得你所有的元素都往后移动，于是你当前访问的第5个元素就会被重复访问。java认为在迭代过程中，容器应当保持不变。因此，java容器中通常保留了一个域称为modCount，每次你对容器修改，这个值就会加1。当你调用iterator方法时，返回的迭代器会记住当前的modCount，随后迭代过程中会检查这个值，一旦发现这个值发生变化，就说明你对容器做了修改，就会抛异常。

    