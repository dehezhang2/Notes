# CS 3334

---------

## Lec2

---------

* Linked list

  * Insert

    * consider special case of empty list
    * Case1: add in front of the list : 

    ```
    newnode->next = first;
    first = newnode
    ```

    * Case2: Insert in the middle

    ```
    newnode->next = p->next;
    p->next = newnode;
    ```

    * Case3: Insert at the end

    ```
    // same as the case 3 => reuse the code
    ```

  * Remove

    * Search by value remove by reference
    * Cases : beginning/not beginning
      * Case1 : Remove at the beginning of the list
        * Current status : the node pointed by "first" is unwanted ```first=first->next``` 
        * ```q=first;first=q->next;delete q;```
      * Case 2 : Remove a node not at the beginning of the list
        * ```p->next = q->next; delete q;```

* Dummy Header Node

  * In order to remove the empty case

* Double-linked list

  * add a Link to the pre node for every node

* Disadvantage : random access time *O(n)* 

---------

## Lec 03

---------

* Correctness of Algorithm 
  * intialization: It is true prior to the first iteration of the loop 
  * Maintenance:  If it is true before an iteration, it remains true before the next iteration 
  * Termination:  When the loop terminates, the invariant gives a useful property that helps to show the algorithm is correct 
* Running time of Insertion Sort

```c++
for(int i=1;i<n;i++)		// n times (last one check add 1)
	key = A[j];				// n-1
	i = j-1	;				// n-1
    while(i>=0&&A[i]>key)	// sum of n-1 ts (different t for each time)
```

* Kind of Analysis

  * Worst case : Usually used => guarantee about the upper bound
  * Average case : Sometimes => Often as bad as worst case
  * Best case : rarely => to prove the algorithm is **bad**

* Asymptotic Notation

  * For all f(n) in $\Theta (n^4)$ , the shape of curve is similar

    * O - notation ("Big-oh") $\approx$ <= (upper bound)

    $$
    O(g(n))=\{f(n):\exists (c\ and\ n_0)\ s.t.\ 0 \leq f(n) \leq cg(n)for\ \forall n \geq n_0\}
    $$

    * $\Omega$ - notation ("Big-omega") $\approx$ >= (lower bound)

    $$
    \Omega(g(n))=\{f(n):\exists (c\ and\ n_0)\ s.t.\ 0 \leq cg(n) \leq f(n) for\ \forall n \geq n_0\}
    $$

    * $\Theta$ - notation ("theta") $\approx$ (sandwich)

  * $$
    \Theta(g(n))=\{f(n):\exists (c_1,\ c_2\ and\ n_0)\ s.t.\ 0 \leq c_1g(n) \leq f(n) \leq c_2g(n) for\ \forall n \geq n_0\}
    $$

    * We don't use symbol of $\Theta$, we use *O* 

      * o (little o) o meas better

      * o(g(n)) must be slightly bigger (whater ever constant equals what)

      * 最优的可能 is g(n)
        $$
        logn<sqrt(n)<n<nlogn<n2 <n4 <2n <n!
        $$

  * When calculating asymptotic running time

    - Drop low-order terms
    - Ignore leading constants 
    - because O is sandwich (but can't use o)

  * In general

    * For each For-loop (O*=n)

    * If else $max(O(statement1),O(statement2))$

      ```c++
      if(n>10)
          // O(n)
          for(i=0;i<n/2;i++)
          	x++;
      else{
          // total situation <=50
          for(i=0;i<n;i++)
          	for(j=0;j<n/2;j++)
          		x--;
      }
      // O(n) in total
      ```

--------

## Tutorial 3

* Suppose we have a pointer to a node in a singly linked list that is guaranteed not to be the last  node in the list. We do not have pointers to any other nodes (except by following links). We also  do not know “first”. Describe an algorithm that logically removes the value stored in such a node  from the linked list, maintaining the correctness of the linked list

  ```C++
  p->val = p->next->val;
  Node* pn = p->next;
  p->next = pn->next;
  delete pn;
  ```

* In singly linked list, write a member function Swap(ListNode* p ListNode* q) which swaps the  order of the adjacent two nodes pointed by p and q (satisfying p->next==q). You can only change  the links （**not data**）in your implementation and the pointer “first” is known.

  ```C++
  
  p->next = q->next;
  q->next = p;
  if(p!=first){
  	Node* pF = findFront(p);
  	pF->next = q;
  }
  else{
      first = q;
  }
  
  // findFront function
  Node* ans = first;
  while(ans->next!=p) ans = ans->next;
  return ans;
  ```

* small o
  $$
  f(n)=o(g(n)) \iff lim_{n->infinity} {f(n)\over g(n)} = 0
  $$

* Coin flipping

  * change the order of fliping row or column will not effect the answer
  * move all column flipping to the front
  * list all the column flipping
  * greedy to the row

* Tower of Hanoi

  * Use fewest steps to move all disks from the source rod to the target without violating the rules through the whole process (given one intermediate rod for buffering)? 

    * Move first n-1 two the second 

    * Move the last to the third

    * Move the n-1 to the third

    * move n-1 twice, and last one on
      $$
      a[N]=a[N-1]*2+1
      $$



    ```c++
    void Towers (int n, int Source, int Target, int Interm) { 
      if(n==1)
    	cout<<“From”<<Source<<“To”<<Target<<endl; 
      else
      { 
        Towers(n-1, Source, Interm, Target);
    	Towers(1, Source, Target, Interm);
    	Towers(n-1, Interm, Target, Source); 
      }
    }
    ``


​    

## Stack

------

* Use Dynamic Array
  * maintain capacity of data[]
  * double ```capacity``` when ```size=capacity```
  * Half capacity when ``size<=capacity/4``
  * E.g., initial cap is 4; I, I, I, I, I (expand; cap=8, size=5), D (shrink; cap=4, size=4), I (expand; cap=8, size=5), D (shrink; cap=4, size=4), I (expand), D (shrink), .... (避免临界时的重复操作)
* Generating(or solve) a maze => use DFS

----------

## Hash

-----------

